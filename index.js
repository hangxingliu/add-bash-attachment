/*!
 * add-bash-attachment
 * Copyright(c) 2018-2019 Liu Yue
 * GPL-3.0 Licensed
 */
//@ts-check
/// <reference path="./types.d.ts" />

const fs = require('fs');
const path = require('path');

const attachmentPrefix = '__bash_attachment_file_';
/** @type {PackageInfo} */
const packageInfo = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf8'));
const validOptions = {
	input: 'input',
	output: 'output',
	attachment: 'attachment',
	help: 'help',
	version: 'version',
};

const reject = message => Promise.reject(new Error(message));
const escapedShellString = string => ("'" + string.replace(/'/g, "'\\''") + "'");

const readFile = (file, encoding) => new Promise((resolve, reject) => {
	fs.readFile(file, encoding ? { encoding } : {}, (error, content) => {
		if (error) return reject(error);
		return resolve(content);
	});
});
const writeFile = (file, content) => new Promise((resolve, reject) => {
	fs.writeFile(file, content, error => {
		if (error) return reject(error);
		return resolve();
	});
});

function help() {
	console.log([
		'',
		`  Usage: ${packageInfo.name} [...options]`,
		'',
		'  Options:',
		'',
		`    --${validOptions.input}       <inputPath>            input file`,
		`    --${validOptions.output}      <outputPath>           output file`,
		`    --${validOptions.attachment}  <attachmentFilePath>   add attachment file`,
		'',
		'  Example:',
		'',
		`    ${packageInfo.name} --input raw.sh \\`,
		'        --file signs.key--file sources.list \\',
		'        --output install.sh',
		'',
	].join('\n'));
}
function version() { console.log(packageInfo.version); }


/** @param {AddAttachments_Attachment[]} files */
function generateHeader(files) {
	return [
		``,
		`# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`,
		`# This function "get_bash_attachment" is generated by project:`,
		`#      ${packageInfo.homepage}`,
		`# Usage: get_bash_attachment "$fileName"`,
		`get_bash_attachment() {`,
		`  case "$1" in`,
		...(files.map((file, index) =>
			`    ${escapedShellString(file.name)}) echo "$${attachmentPrefix}${index}" | base64 -d - ;;`)),
		`  esac`,
		`}`,
		...(files.map((file, index) => {
			return [
				`${attachmentPrefix}${index}='`,
				file.content.toString('base64').replace(/[\w\/+=]{76}/g, '$&\n'),
				`'`,
			].join('\n');
		})),
		`# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<`,
	].join('\n');
}


/**
 * @param {string} scriptContent
 * @returns {{shebang: string; scripts: string}}
 */
function extractShebang(scriptContent) {
	if (typeof scriptContent !== 'string') return { shebang: '', scripts: scriptContent };
	const mtx = scriptContent.match(/^\s*#!.+/);
	const shebang = mtx ? mtx[0] : '';
	return { shebang, scripts: shebang ? scriptContent.slice(shebang.length) : scriptContent };
}

/**
 * @param {AddAttachments} options
 * @returns {Promise<string>}
 */
function addAttachments(options) {
	if (!options || typeof options !== 'object')
		return reject('options is required!');

	if (!Array.isArray(options.attachments))
		return reject('options.attachments should be an array!');

	options.attachments.forEach((it, index) => {
		if (typeof it.name !== 'string' || !it.name)
			return reject(`options.attachments[${index}].name is not a string or empty!`);
		if (!Buffer.isBuffer(it.content))
			return reject(`options.attachments[${index}].content is not a Buffer!`);
	});

	/** @type {Promise<string>} */
	let promiseChains = null;
	if (typeof options.inputScript !== 'string') {
		if (typeof options.inputFile !== 'string')
			return reject('options must contains one of "inputScript" and "inputFile"!');
		promiseChains = readFile(options.inputFile, 'utf8');
	} else {
		promiseChains = Promise.resolve(options.inputScript);
	}

	return promiseChains.then(fileContent => {
		if (options.attachments.length == 0)
			return Promise.resolve(fileContent);
		const { shebang, scripts } = extractShebang(fileContent);
		return Promise.resolve([
			shebang,
			generateHeader(options.attachments),
			scripts,
		].join('\n'));
	});
}

/**
 * @param {string[]} argv
 */
function cli(argv) {
	/** @type {AddAttachments} */
	const options = { attachments: [] };
	/** @type {string[]} */
	const attachmentPaths = [];
	let outputFile = '';

	if (argv.length <= 0)
		return help();
	for (let i = 0; i < argv.length; i+=2) {
		const rawOptName = argv[i];
		const optName = rawOptName.slice(2);
		if (rawOptName == '--help' || rawOptName == '-h')
			return help();
		if (rawOptName == '--version' || rawOptName == '-V')
			return version();
		if (!rawOptName.startsWith('--') || !Object.prototype.hasOwnProperty.call(validOptions, optName)) {
			console.error(`error: unknown option ${JSON.stringify(rawOptName)}!`);
			process.exit(1);
		}

		const optValue = argv[i + 1];
		if (!optValue) {
			console.error(`error: empty value for ${JSON.stringify(rawOptName)}!`);
			process.exit(1);
		}

		switch (optName) {
			case validOptions.input:
				options.inputFile = optValue;
				break;
			case validOptions.output:
				outputFile = optValue;
				break;
			case validOptions.attachment:
				attachmentPaths.push(optValue);
				break;
			default:
		}
	}

	const attachmentNames = attachmentPaths.map(it => path.basename(it));
	const duplicatedCheck = new Set();
	for (const fileName of attachmentNames) {
		if (duplicatedCheck.has(fileName)) {
			console.error(`error: file name ${JSON.stringify(fileName)} is duplicated!`);
			process.exit(1);
		}
		duplicatedCheck.add(fileName);
	}

	Promise.all(attachmentNames.map(it => readFile(it)))
		.then(contents => {
			options.attachments = contents.map((content, index) => ({
				name: attachmentNames[index], content,
			}));
			return addAttachments(options);
		}).then(newScript => {
			if (!outputFile) {
				console.log(newScript);
				return Promise.resolve();
			}

			return writeFile(outputFile, newScript).then(() => {
				console.error(`success: new script has been wrote to ${outputFile}`);
			});
		}).catch(ex => {
			console.error(`error: ${ex.stack}`);
			process.exit(1);
		});
}

module.exports = {
	extractShebang,
	addAttachments,
	cli
}
